{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MicroTrace Overview","text":"<p>An intelligent system for firmware reverse engineering, component classification, and vulnerability analysis.</p> <p> </p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Project Overview</li> <li> <p>Project Phases</p> </li> <li> <p>Phase 1 \u2013 SBOM Extraction and Visualization</p> </li> <li> <p>Phase 2 \u2013 AI-Driven Analysis and Vulnerability Detection</p> </li> <li> <p>Key Technologies</p> </li> <li>Time Plan</li> <li>Final Outcomes</li> <li>Use Cases</li> </ul>"},{"location":"#project-overview","title":"Project Overview","text":"<p>MicroTrace is a research and development project designed to automatically generate a Software Bill of Materials (SBOM) from bare-metal embedded firmware. By reverse-engineering binaries and analyzing function patterns, MicroTrace identifies software layers such as MCAL, HAL, Middleware, and Application logic, and presents them through an interactive web visualization.</p> <p>The project integrates reverse engineering, AI, and cybersecurity to improve firmware transparency, vulnerability detection, and supply chain security.</p>"},{"location":"#project-phases","title":"Project Phases","text":""},{"location":"#phase-1-sbom-extraction-and-visualization","title":"Phase 1 \u2013 SBOM Extraction and Visualization","text":"<p>Goal: Build an automated pipeline that extracts functions from a firmware binary, classifies them into layers, and visualizes the architecture as an interactive graph.</p> <p>Workflow:</p> <ol> <li>Input: Upload a <code>.elf</code> or <code>.bin</code> firmware file.</li> <li>Disassembly &amp; Function Extraction: Use Ghidra Headless to extract functions, symbols, and call relationships. Export results as structured JSON.</li> <li>Component Classification (MCAL/HAL): Detect MCAL, HAL, and main/application logic modules.</li> <li>Frontend Visualization: Display results on a web-based Node Graph.</li> <li>RAG Assistant Integration: Enable natural-language queries about hardware registers or function purposes.</li> </ol> <p>Deliverables:</p> <ul> <li>Automated disassembly backend</li> <li>MCAL/HAL classification system</li> <li>AI datasheet assistant prototype</li> <li>Web UI for function visualization</li> </ul>"},{"location":"#phase-2-ai-driven-analysis-and-vulnerability-detection","title":"Phase 2 \u2013 AI-Driven Analysis and Vulnerability Detection","text":"<p>Goal: Use AI and vulnerability data to identify unknown functions, detect reused libraries, and flag potential security risks.</p> <p>Workflow:</p> <ol> <li>AI-Based Function Mapping: Fingerprint unknown code and match against known libraries.</li> <li>Vulnerability Detection: Check libraries against CVE databases and alert users to risks.</li> <li>Plagiarism &amp; Similarity Analysis: Detect code reuse or intellectual property violations.</li> </ol> <p>Deliverables:</p> <ul> <li>AI-based library and function classifier</li> <li>CVE lookup and vulnerability reporting module</li> <li>SPDX/CycloneDX SBOM exporter</li> <li>Enhanced dashboard with alerts and recommendations</li> </ul>"},{"location":"#key-technologies","title":"Key Technologies","text":"Component Tool / Framework Purpose Disassembly &amp; Analysis Ghidra Headless, Capstone, Radare2 Extract functions and instructions Pattern Matching MCAL/HAL rules Detect known low-level code AI Assistant (RAG) LangChain / LlamaIndex Query hardware datasheets Frontend Visualization React + D3.js / Cytoscape.js Interactive function graph Vulnerability Detection NVD API / CVE Feeds Identify known CVEs SBOM Format SPDX / CycloneDX Standardized compliance reports"},{"location":"#time-plan","title":"Time Plan","text":"Phase Duration Milestones Week 1\u20132 Setup Repo initialization, architecture design, sample firmware Week 3\u20135 Disassembly Automate Ghidra extraction and JSON output Week 6\u20138 Classification Develop and test MCAL/HAL rules Week 9\u201310 Visualization Implement frontend graph with live data Week 11\u201312 RAG Assistant Embed datasheets and test AI queries Week 13\u201314 Fingerprinting Train/test AI model for unknown functions Week 15\u201317 Vulnerability Analysis CVE integration and SBOM export Week 18+ Final Integration System testing, frontend polish, finalize documentation"},{"location":"#final-outcomes","title":"Final Outcomes","text":"<ul> <li>Automated SBOM extractor</li> <li>Interactive code architecture graph</li> <li>AI assistant for hardware and logic analysis</li> <li>Integrated vulnerability and compliance scanner</li> <li>Optional code similarity / plagiarism detection</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Firmware Security Auditing</li> <li>Supply Chain Verification</li> <li>Reverse Engineering and Learning</li> <li>Intellectual Property Protection</li> <li>Embedded Software Education</li> </ul> <p>MicroTrace \u2014 Bridging Embedded Systems, Security, and AI</p>"},{"location":"mcp/","title":"MCP Server Documentation","text":""},{"location":"mcp/#table-of-contents","title":"Table of Contents","text":"<ol> <li>What is MCP?</li> <li>How MCP Works</li> <li>What We Did</li> <li>Setup Steps</li> <li>Example: PDF Reader Tool</li> <li>Project Structure</li> <li>Commands Reference</li> <li>Future Work Hints</li> <li>Key Takeaways</li> <li>Summary</li> </ol>"},{"location":"mcp/#what-is-mcp","title":"What is MCP?","text":"<p>MCP (Model Context Protocol) enables AI assistants (like Claude) to access external tools and data.</p> <p>Analogy: Think of Claude as a person sitting at a desk:</p> <ul> <li>Without MCP: Can only answer questions from memory</li> <li>With MCP: Can pick up tools from the desk (calculator, file reader, analyzer) and use them</li> </ul> <p>Pattern:</p> <pre><code>User asks a question\n        \u2193\nClaude decides it needs a tool\n        \u2193\nClaude calls your MCP server\n        \u2193\nServer executes the tool\n        \u2193\nResult returned to Claude\n        \u2193\nClaude uses result to answer\n</code></pre> <p>Example:</p> <pre><code>User: \"What's in firmware.bin?\"\nClaude: [Calls MCP tool \"analyze_firmware\"]\nServer: [Analyzes file, returns \"ARM Cortex-M, 256KB\"]\nClaude: \"This is ARM Cortex-M firmware, 256KB in size.\"\n</code></pre>"},{"location":"mcp/#how-mcp-works","title":"How MCP Works","text":""},{"location":"mcp/#three-main-components","title":"Three Main Components","text":"<ol> <li> <p>MCP Server</p> </li> <li> <p>Defines available tools</p> </li> <li>Implements tool logic</li> <li>Runs as a separate process</li> </ol> <pre><code>from mcp.server import Server\nimport mcp.server.stdio\n\napp = Server(\"my-server\")\n\n@app.list_tools()\nasync def list_tools():\n    return [...]\n\n@app.call_tool()\nasync def call_tool(name, arguments):\n    return [...]\n</code></pre> <ol> <li> <p>MCP Protocol</p> </li> <li> <p>Standard communication between Claude and your server</p> </li> <li>Uses stdin/stdout with JSON messages</li> </ol> <pre><code>Claude \u2192 {\"method\": \"call_tool\", \"params\": {...}} \u2192 Server\nServer \u2192 {\"result\": \"...\"} \u2192 Claude\n</code></pre> <ol> <li> <p>MCP Client</p> </li> <li> <p>Connects to the server</p> </li> <li>Sends requests and receives responses</li> </ol> <p>Option A: Claude Desktop (easiest)</p> <pre><code>{\n  \"mcpServers\": {\n    \"my-tools\": {\n      \"command\": \"python\",\n      \"args\": [\"server.py\"]\n    }\n  }\n}\n</code></pre> <p>Option B: Custom Client</p> <pre><code>from mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nserver_params = StdioServerParameters(command=\"python\", args=[\"server.py\"])\n\nasync with stdio_client(server_params) as (read, write):\n    async with ClientSession(read, write) as session:\n        result = await session.call_tool(\"tool_name\", {...})\n</code></pre>"},{"location":"mcp/#what-we-did","title":"What We Did","text":"<ul> <li>Learned what MCP is and how it works</li> <li>Understood that Claude Desktop is optional</li> <li>Created the first MCP server with a \"hello world\" tool</li> <li>Built a practical example (PDF reader)</li> <li> <p>Planned embedded reverse-engineering tools:</p> </li> <li> <p>Firmware architecture detection</p> </li> <li>String extractor</li> <li>Disassembler</li> <li>Firmware extractor</li> <li>Memory layout analyzer</li> <li>Peripheral database</li> </ul>"},{"location":"mcp/#setup-steps","title":"Setup Steps","text":"<ol> <li>Install UV (Python Package Manager)</li> </ol> <p>macOS/Linux:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Windows:</p> <pre><code>powershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Verify installation:</p> <pre><code>uv --version\n</code></pre> <ol> <li>Create Project</li> </ol> <pre><code>mkdir embedded-re-mcp\ncd embedded-re-mcp\nuv init\n</code></pre> <ol> <li>Add MCP Dependency</li> </ol> <pre><code>uv add mcp\n</code></pre> <ol> <li>Create MCP Server (<code>src/server.py</code>)</li> </ol> <pre><code>from mcp.server import Server\nfrom mcp.types import Tool, TextContent\nimport mcp.server.stdio\n\napp = Server(\"my-first-server\")\n\n@app.list_tools()\nasync def list_tools() -&gt; list[Tool]:\n    return [Tool(name=\"hello\", description=\"Say hello\", inputSchema={\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\"}},\"required\":[\"name\"]})]\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:\n    if name == \"hello\":\n        return [TextContent(type=\"text\", text=f\"Hello, {arguments['name']}!\")]\n    return [TextContent(type=\"text\", text=\"Unknown tool\")]\n\nif __name__ == \"__main__\":\n    mcp.server.stdio.stdio_server()(app)\n</code></pre> <ol> <li>Run Server</li> </ol> <pre><code>uv run python src/server.py\n</code></pre> <ol> <li> <p>Connect to Claude Desktop (Optional)    Edit <code>claude_desktop_config.json</code> with your server path.</p> </li> <li> <p>Custom Client Example (<code>src/client.py</code>)</p> </li> </ol> <pre><code>import asyncio\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nasync def main():\n    server_params = StdioServerParameters(command=\"uv\", args=[\"run\",\"python\",\"src/server.py\"])\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n            result = await session.call_tool(\"hello\", {\"name\": \"World\"})\n            print(result[0].text)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"mcp/#example-pdf-reader-tool","title":"Example: PDF Reader Tool","text":"<ul> <li>Install dependency:</li> </ul> <pre><code>uv add PyPDF2\n</code></pre> <ul> <li>Create <code>src/pdf_server.py</code> with tools <code>read_pdf_titles</code> and <code>count_pages</code></li> <li>Implements MCP pattern like the hello example</li> </ul>"},{"location":"mcp/#project-structure","title":"Project Structure","text":"<pre><code>embedded-re-mcp/\n\u251c\u2500\u2500 .python-version\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 uv.lock\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 server.py\n    \u251c\u2500\u2500 client.py\n    \u251c\u2500\u2500 pdf_server.py\n    \u2514\u2500\u2500 tools/\n        \u251c\u2500\u2500 firmware_analyzer.py\n        \u251c\u2500\u2500 disassembler.py\n        \u2514\u2500\u2500 arch_detector.py\n</code></pre>"},{"location":"mcp/#commands-reference","title":"Commands Reference","text":"<pre><code>uv init\nuv add mcp\nuv add PyPDF2\nuv run python src/server.py\nuv run python src/client.py\nuv sync\nuv add package-name\n</code></pre>"},{"location":"mcp/#future-work-hints","title":"Future Work Hints","text":"<p>Build embedded RE tools following the MCP pattern:</p> <ol> <li>Architecture detector (ARM/MIPS/RISC-V)</li> <li>String extractor</li> <li>Disassembler (Capstone)</li> <li>Firmware extractor (Binwalk)</li> <li>Memory layout analyzer</li> <li>Peripheral database</li> </ol>"},{"location":"mcp/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>MCP is a protocol, not tied to Claude Desktop</li> <li>Three components: Server, Protocol, Client</li> <li>Start simple (hello or PDF reader)</li> <li>Every tool follows the same pattern: name, description, schema, implementation</li> <li>Use MCP anywhere: CLI, web, GUI, plugins</li> </ol>"},{"location":"mcp/#summary","title":"Summary","text":"<p>MCP = AI access to your tools</p> <p>Pattern:</p> <ol> <li>Define tools (name, description, schema)</li> <li>Implement tools (code)</li> <li>Run server</li> <li>Use from Claude or your own client</li> </ol> <p>We built:</p> <ul> <li>Understanding of MCP</li> <li>UV setup and project structure</li> <li>Hello world tool</li> <li>PDF reader tool</li> <li>Plan for embedded reverse-engineering tools   Everything else builds on this foundation.</li> </ul>"},{"location":"svd_database/","title":"SVD Database Documentation","text":""},{"location":"svd_database/#overview","title":"Overview","text":"<p>Purpose: This module parses ARM CMSIS SVD files and reference-manual PDFs for an STM32 microcontroller family. It extracts peripherals, registers, and fields, and stores a flattened, query-friendly representation in MongoDB.</p> <p>The dataset allows quick lookup of register addresses, field bit offsets/widths, and textual descriptions for use in tooling, documentation generation, or verification.</p> <p>Target Database: MongoDB Atlas. The code uses <code>pymongo</code> and expects a standard connection URI. The main collection stores one document per register-field pair, or one document per register if no fields are present.</p>"},{"location":"svd_database/#imports-overview","title":"Imports Overview","text":"<p>These Python modules provide the required functionality:</p> <ul> <li>os, re, io, copy \u2013 utility and file operations</li> <li>xml.etree.ElementTree \u2013 parsing SVD XML files</li> <li>pymongo \u2013 MongoDB database connectivity</li> <li>fitz (PyMuPDF) \u2013 extracting text and images from PDFs</li> <li>pytesseract + PIL \u2013 OCR for unreadable PDF pages</li> </ul> <p>Code:</p> <pre><code>import os, sys, re, io, copy\nimport xml.etree.ElementTree as ET\nfrom pymongo import MongoClient\nimport fitz, pytesseract\nfrom PIL import Image\n</code></pre>"},{"location":"svd_database/#mongodb-connection","title":"MongoDB Connection","text":"<p>This function connects to MongoDB Atlas, verifies connectivity, and returns the collection object for inserting documents.</p> <pre><code>def connect():\n    c = MongoClient(MONGO_URI, tls=True)\n    c.admin.command(\"ping\")\n    return c[DB][COL]\n</code></pre>"},{"location":"svd_database/#pdf-base-address-extraction","title":"PDF Base Address Extraction","text":"<p>Reads the reference manual PDF and extracts base addresses for peripherals. OCR is used when a PDF page contains little or no readable text.</p> <pre><code>def extract_pdf_bases(path):\n    if not os.path.exists(path):\n        return {}\n    txt = \"\"\n    for pg in fitz.open(path):\n        t = pg.get_text()\n        if len(t.strip()) &lt; 40:\n            img = Image.open(io.BytesIO(pg.get_pixmap(dpi=200).tobytes(\"png\")))\n            t = pytesseract.image_to_string(img)\n        txt += t + \"\\n\"\n    bases = {}\n    for m in re.finditer(r\"([A-Z][A-Z0-9_]+)[^\\w]{0,10}(0x[0-9A-Fa-f]{6,8})\", txt):\n        bases[m.group(1)] = m.group(2).upper()\n    return bases\n</code></pre>"},{"location":"svd_database/#peripheral-expansion-handling-derivedfrom","title":"Peripheral Expansion (Handling <code>derivedFrom</code>)","text":"<p>SVD allows peripherals to inherit structure from others using <code>derivedFrom</code>. This function recursively expands inherited peripherals and merges fields correctly.</p> <pre><code>def expand(peripherals, name, seen=None):\n    if name not in peripherals:\n        return None\n    seen = seen or set()\n    if name in seen:\n        return None\n    seen.add(name)\n    node = peripherals[name][\"raw\"]\n    base = peripherals[name][\"derived\"]\n    if base:\n        bnode = expand(peripherals, base, seen)\n        if bnode is not None:\n            m = copy.deepcopy(bnode)\n            for ch in node:\n                if ch.tag in [\"registers\",\"clusters\"]:\n                    for old in m.findall(ch.tag):\n                        m.remove(old)\n                m.append(copy.deepcopy(ch))\n            m.find(\"name\").text = node.findtext(\"name\")\n            m.find(\"baseAddress\").text = node.findtext(\"baseAddress\", m.findtext(\"baseAddress\",\"0x0\"))\n            return m\n    return node\n</code></pre>"},{"location":"svd_database/#svd-parsing","title":"SVD Parsing","text":"<p>The main logic reads SVD peripherals, registers, clusters, and fields. It calculates addresses, merges PDF bases, and produces MongoDB-ready documents.</p> <pre><code>def parse_svd(path, pdf_bases):\n    tree = ET.parse(path)\n    root = tree.getroot().find(\"peripherals\")\n    per = {p.findtext(\"name\"):{\"raw\":p,\"derived\":p.get(\"derivedFrom\")} for p in root}\n    docs = []\n\n    def add(reg, P, desc, bint, bhex, pref=\"\"):\n        rname = pref + reg.findtext(\"name\",\"\").upper()\n        off = int(reg.findtext(\"addressOffset\",\"0x0\"),0)\n        hexaddr = hex(bint+off).upper()\n        fields = reg.find(\"fields\")\n        if fields is None:\n            docs.append({\n                \"PERIPHERAL\": P,\n                \"DESCRIPTION\": desc,\n                \"BASEADDRESS\": bhex,\n                \"REGISTER\": rname,\n                \"REGISTER_DESCRIPTION\": reg.findtext(\"description\",\"\"),\n                \"ADDRESSOFFSET\": hex(off).upper(),\n                \"RESETVALUE\": reg.findtext(\"resetValue\",\"0\"),\n                \"HEXADDRESS\": hexaddr,\n                \"FIELD\": None,\n                \"FIELD_DESCRIPTION\": None,\n                \"BITOFFSET\": None,\n                \"BITWIDTH\": None\n            })\n        else:\n            for f in fields.findall(\"field\"):\n                docs.append({\n                    \"PERIPHERAL\": P,\n                    \"DESCRIPTION\": desc,\n                    \"BASEADDRESS\": bhex,\n                    \"REGISTER\": rname,\n                    \"REGISTER_DESCRIPTION\": reg.findtext(\"description\",\"\"),\n                    \"ADDRESSOFFSET\": hex(off).upper(),\n                    \"RESETVALUE\": reg.findtext(\"resetValue\",\"0\"),\n                    \"HEXADDRESS\": hexaddr,\n                    \"FIELD\": f.findtext(\"name\",\"\"),\n                    \"FIELD_DESCRIPTION\": f.findtext(\"description\",\"\"),\n                    \"BITOFFSET\": int(f.findtext(\"bitOffset\",\"0\")),\n                    \"BITWIDTH\": int(f.findtext(\"bitWidth\",\"0\"))\n                })\n\n    for name in per:\n        node = expand(per, name)\n        if node is None:\n            continue\n        P = node.findtext(\"name\",\"N/A\").upper()\n        base = pdf_bases.get(P, node.findtext(\"baseAddress\",\"0x0\"))\n        bint = int(base,0)\n        bhex = hex(bint).upper()\n        desc = node.findtext(\"description\",\"\")\n\n        regs = node.find(\"registers\")\n        if regs:\n            for r in regs.findall(\"register\"):\n                add(r, P, desc, bint, bhex)\n\n        for cl in node.findall(\".//cluster\"):\n            cpre = cl.findtext(\"name\",\"\").upper()+\"_\"\n            coff = int(cl.findtext(\"addressOffset\",\"0x0\"),0)\n            for r in cl.findall(\"register\"):\n                add(r, P, desc, bint+coff, bhex, cpre)\n\n    return docs\n</code></pre>"},{"location":"svd_database/#mongodb-insertion-workflow","title":"MongoDB Insertion Workflow","text":"<p>The <code>main()</code> function runs the complete pipeline: connects to the database, extracts PDF bases, parses SVD, clears old documents, and inserts the new structured dataset.</p> <pre><code>def main():\n    col = connect()\n    bases = extract_pdf_bases(PDF)\n    docs = parse_svd(SVD, bases)\n    col.delete_many({})\n    col.insert_many(docs)\n    print(\"DONE:\", len(docs), \"records uploaded.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"svd_database/#database-example","title":"Database Example","text":"<p>Collection: <code>stm32_registers_full</code></p> <pre><code>{\n  \"PERIPHERAL\": \"FLASH\",\n  \"DESCRIPTION\": \"Flash memory control registers\",\n  \"BASEADDRESS\": \"0X40023C00\",\n  \"REGISTER\": \"ACR\",\n  \"REGISTER_DESCRIPTION\": \"Flash access control register\",\n  \"ADDRESSOFFSET\": \"0X0\",\n  \"RESETVALUE\": \"0X20\",\n  \"HEXADDRESS\": \"0X40023C00\",\n  \"FIELD\": \"LATENCY\",\n  \"FIELD_DESCRIPTION\": \"Latency\",\n  \"BITOFFSET\": 0,\n  \"BITWIDTH\": 3\n}\n</code></pre> <p>Screenshot: Include a screenshot of the MongoDB document view for clarity.</p>"}]}